package main

/**
	散列表查找定义：存储位置 = f(关键字)
	f成为散列函数又称为Hash函数，采用散列技术将记录存储在一块连续的存储空间中，这块连续的储存空间称为散列表或 哈希表(Hash table)
	散列既是存储技术也是一种查找技术
	两个关键字key1 != key2 但却有f(key1) = f(key2) 这种现象我们称之为冲突 key1 和 key2 叫做同义词

	散列函数构造方法：
	1、直接定址法：取关键字的某个线性函数值作为散列地址---适合较小且连续（0-100）
		f(key) = a * key + b ; a,b为常数

	2、数字分析法----手机号码取最后4位

	3、平方取中法---1234 平方1522756 再取中间3位 227 作为散列地址
	4、折叠法
		折叠法是将关键字从左至右分割成位数相等的几部分（最后一位不够可以短些）然后将折叠部分叠加求和，并按散列表表长，去最后几位作为散列地址
	5、除留余数法 ---最常用的构造散列函数的方法
		f(key) = key % p (p<=m) ; m为散列表长
			根据经验p通常为小于或等于（最好接近m）的最小质数或不包含小于20的质因子的和数
	6、随机数法
		f(key) = random(key) ---当关键字长度不等时采用这个比较合适

	处理冲突的方法：
	1、开放定址法
		开放定址法就是一旦发生了冲突，就寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到并记录存入
	f(key) = (f(key)+ d) % m(d=1,2,3,.....m-1)
   2、再散列函数
   	f(key) = RH(key)  RH就是不同的散列函数
   3、链地址发
	先除留余数法求得key,然后将所有同义词存在一个单链表里 ---提供了不会找不到地址的保障但增加了查找链表的耗时
   4、公共溢出区法
	将同义词全部存在另外一个溢出表里,这样通过key得到散列地址后先判断是否相等，如果不相等在遍历溢出表

 */
